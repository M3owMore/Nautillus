import CMD from "./CMD";
import LNK from "./LNK";
import LS from "./LI";
import LST from "./LST";
import SPC from "./SPC";
import IMG from "./IMG.tsx";
import InlineCode from "./InlineCode";
import Window from "./Window"
import P from "./P.tsx";
import {H1, H2, H3, H4} from "./H1";
import Code from "./Code";

const Test = (props:any) => {
    return (
        <>
<Window i={1}>
    <H3>გაკვეთილი  1:</H3>
    <H1>შესავალი</H1>
    <br/>
    <P><InlineCode>ლინუქსი(Linux)</InlineCode> ფართოდ გავრცელებული ოპერაციული სისტემაა(Operating System). სერვერთა 96%-ზე მეტი მუშაობს ლინუქსზე, ეს ნიშნავს, რომ ყველაზე გავრცელებული <InlineCode>OS(Operating System-ის შემოკლებული ფორმა)</InlineCode> გახლავთ ლინუქსი. შეგვიძლია ვთქვათ, რომ <InlineCode>IT ინდუსტრია</InlineCode> მთლიანად ამ ოპერაციულ სისტემაზეა დაშენებული. ლინუქსის გარეშე, მთლიანი ინფრასტრუქტურა ჩამოიშლება. როდესაც ჰაკერი ან პროფესიონალი კიბერუსაფრთხოების სპეციალისტი გახდებით, უმეტესად ლინუქსთან მუშაობა მოგიწევთ.</P>
    <P>რა არის ლინუქსი? როგორც დამწყებს, დიდი შანსია, რომ ოპერაციული სისტემების მნიშვნელობა არ იცით. მის დეფინიციას გაგაცნობთ: ოპერაციული სისტემა არის პროგრამა, რომელიც <InlineCode>მოწყობილობის აპარატურის(Hardware)</InlineCode> გასაკონტროლებლადაა საჭირო და ამ მოწყობილობებს მომხმარებელთათვის ადვილად გამოყენებადს ხდის. ოპერაციული სისტემის გარეშე, ყველა მოწყობილობა უსარგებლოა. წარმოიდგინეთ კომპიუტერი <InlineCode>Windows</InlineCode>-ის გარეშე(შესაძლებელია სხვა ოპერაციული სისტემის გამოყენება, მაგრამ მოდით წარმოვიდგინოთ, რომ კომპიუტერზე არაფერი არაა დაყენებული), ის უსარგებლო იქნება. ანუ, იმის თქმა გვსურს, რომ მოწყობილობებს ოპერაციული სისტემა სჭირდებათ იმისათვის, რომ მუშაობა შეძლონ. დიახ, მოწყობილობებს იმიტომ, რომ მხოლოდ კომპიუტერებს, სერვერებს და სმარტფონებს არ სჭირდება <InlineCode>OS</InlineCode>. ყველა <InlineCode>IoT(Internet of Things)</InlineCode> მოწყობილობას, მაგალითად: ჭკვიანი <InlineCode>TV</InlineCode>-ები, მანქანები, ჭკვიანი მტვერსასრუტები და ასე შემდეგ. უმეტესობა ლინუქსს იყენებს.</P>
    <P>კარგით, ახლა ვისაუბროთ თუ როგორ და სად გამოიყენება ლინუქსი. უმეტეს შემთხვევაში, ლინუქსს სერვერებზე აინსტალირებენ. რეალურად, თქვენ ლინუქსის გამოყენება კომპიუტერზეც უპრობლემოდ შეგიძლიათ. შეგიძლიათ იმუშაოთ, ფილმებს უყუროთ, ითამაშოთ, პროგრამები შექმნათ ლინუქსზე. ლინუქსი ასევე ქსელურ მოწყობილობებშიც გამოიყენება, როგორებიცაა ფაერვოლები, როუტერები და სვიჩები.</P>
    <P>ლინუქსი სხვა ოპერაციულ სისტემებს არ ჰგავს. როდესაც <InlineCode>Window</InlineCode>-ს აყენებთ თქვენს მოწყობილობაზე, მას ყველაფერი გამზადებული აქვს რაც მუშაობისათვისაა საჭირო. მეორე მხრივ, ლინუქსს <InlineCode>GUI</InlineCode>-ც(Graphical User Interface) კი არ აქვს დასაწყისში. რა თქმა უნდა, არსებობს ლინუქსის დისტრიბუტივები(მოგვიანებით ვისაუბრებთ ამაზე), რომლებსაც წინასწარ აქვთ გამზადებული <InlineCode>GUI</InlineCode>, მაგრამ არსებობს ლინუქსის დისტრიბუტივები, როგორებიცაა <InlineCode>Arch</InlineCode>, <InlineCode>Void</InlineCode> და <InlineCode>Gentoo</InlineCode>, რომლებსაც თავიდან არ აქვთ </P>
    <P>როგორ შეგიძლიათ ლინუქსის გადმოწერა? ამ კითხვაზე პასუხის გაცემა ადვილი არ არის. ამ კითხვაზე რომ გიპასუხოთ, ლინუქსის ისტორია უნდა გაგაცნოთ. თავდაპირველად, ლინუქსი ლინუს ტორვალდსმა შექმნა და თავიდან, ის არ ყოფილა სერიოზული პროექტი. რაღაც დროის შემდეგ, ლინუქსი პოპულარული გახდა და მან მასზე სერიოზულად მუშაობა დაიწყო. პროექტი <InlineCode>ღია წყაროა(Open source)</InlineCode> და ნებისმიერს შეუძლია მასში წვლილის შეტანა. საკუთარი ლინუქსის შექმნაც კი შეგიძლიათ. მათ ლინუქსის დისტროები(დისტრიბუტივები) ეწოდებათ. ბევრ კომპანიას აქვს შექმნილი საკუთარი ლინუქსის დისტრო და ყოველი მათგანი განსხვავებულია. თქვენ საკუთარი დისტროს სხვისაზე დაშენებაც კი შეგიძლიათ. დღესდღეობით, ექვსასზე მეტი დისტრო არსებობს. მოკლედ, კითხვაზე რომ გიპასუხოთ, უნდა გადაწყვიტოთ თუ რომელი დისტრიბუტივის გამოყენება გსურთ. ამ სიტუაციაში, შესაძლოა მეორე კითხვაც დასვათ: “რომელი გამოვიყენო?”. რთულია ამაზე პასუხის გაცემა. ბევრი ადამიანი რეკომენდაციას უწევს <InlineCode>Debian</InlineCode>-ზე(ლინუქსის დისტრიბუტივი) დაშენებული დისტროებს, როგორიცაა <InlineCode>Ubuntu</InlineCode>, მაგრამ თუ ლინუქსის სიღრმისეულად შესწავლა გსურთ, უკეთესია თუ <InlineCode>Void</InlineCode> ლინუქსით დაიწყებთ. რა თქმა უნდა, თუ რთული დისტრიბუტივებით დაწყება არ გსურთ, შეგიძლიათ <InlineCode>Ubuntu</InlineCode>-ს დაინსტალირება.</P>
    <P><InlineCode>Void</InlineCode> ლინუქსის გადმოწერა ამ URL-დან შეგიძლიათ: <LNK to="https://voidlinux.org/download">https://voidlinux.org/download</LNK>. თუ <InlineCode>Ubuntu</InlineCode>-ს დაყენება გადაწყვიტეთ, მისი გადმოწერა ამ URL-დან შეგიძლიათ: <LNK to="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</LNK></P>
</Window>

<Window i={2}>
    <H3>გაკვეთილი  2:</H3>
    <H1>ლინუქსის ინსტალაცია</H1>
    <br/>
    <P>რა უნდა გააკეთოთ ლინუქსის დისტროს გადმოწერის შემდეგ? ეს ყველაფერი იმაზეა დამოკიდებული თუ სად გსურთ ლინუქსის დაყენება. თუ ლინუქსის დაყენება <InlineCode>Virtual machine</InlineCode>-ად გსურთ, შეგიძლიათ <InlineCode>VirtualBox</InlineCode> ან <InlineCode>VMware</InlineCode> გამოიყენოთ, რათა ლინუქსი ვირტუალურ მოწყობილობად აამუშავოთ კომპიუტერში. გაითვალისწინეთ, რომ დამატებითი გამოთვლითი ძალაა საჭირო, რადგან კომპიუტერს ქმნით კომპიუტერში.</P>
    <P>რა თქმა უნდა, შესაძლებელია ლინუქსის მთავარ ოპერაციულ სისტემად დაყენება. რეკომენდირებულია <InlineCode>USB ფლეშ დრაივის(“ფლეშკის”)</InlineCode> ქონა, რომელსაც მინიმუმ <InlineCode>8 GB</InlineCode> მეხსიერება ექნება. როდესაც ლინუქსის ფაილს გადმოიწერთ, გადმოწერეთ პროგრამა სახელად <InlineCode>Rufus</InlineCode> ამ URL-დან: <LNK to="https://rufus.ie/en/#">https://rufus.ie/en/#</LNK>. ეს პროგრამა <InlineCode>USB ფლეშ დრაივის</InlineCode> დასაფორმატებლად გამოიყენება. გახსენით <InlineCode>Rufus</InlineCode> და დააინსტალირეთ(Install) ლინუქსის ფაილი <InlineCode>USB ფლეშ დრაივზე</InlineCode>. როდესაც ყველაფერი დასრულდება, შეგიძლიათ დაარესტარტოთ კომპიუტერი ლინუქსის დასაინსტალირებლად.</P>
    <P>შესაძლოა ერთი პრობლემა გამოჩნდეს, ესაა თქვენი <InlineCode>BIOS ოფციები</InlineCode> . გადადით თქვენი კომპიუტერის <InlineCode>BIOS</InlineCode>-ში და შეცვალეთ boot ოფციები. <InlineCode>USB</InlineCode> ფლეშ დრაივს მიანიჭეთ პრიორიტეტი. შეინახეთ ცვლილებები და დაარესტარტეთ კომპიუტერი. ახლა, შეგიძლიათ ლინუქსის თქვენს კომპიუტერზე დაყენება. რეკომენდაციას ვუწევთ <InlineCode>VirtualBox</InlineCode>-ზე ინსტალაციას მანამ, სანამ კომპიუტერზე დააყენებთ ლინუქსს. ინსტალაციის პროცესი რთული არაა(ეს დამოკიდებულია იმაზე, თუ რომელი დისტროს დაყენება გსურთ. მაგალითად, <InlineCode>Ubuntu</InlineCode>-ს ინსტალაცია ძალიან ადვილია დამწყებთათვისაც კი, მაგრამ <InlineCode>Arch</InlineCode> ლინუქსის ინსტალაცია ისეთ ადამიანებსაც კი უძნელდებათ, რომლებიც ლინუქსს რამდენიმე წელია იყენებენ), მაგრამ პრაქტიკა ყოველთვის კარგია.</P>
    <P>როდესაც ინსტალაციის პროცესი დასრულდება, დაარესტარტეთ კომპიუტერი და მოაშორეთ <InlineCode>USB ფლეშ დრაივი</InlineCode>. თქვენ წარმატებით დააყენეთ ლინუქსი თქვენს კომპიუტერზე.</P>
</Window>

<Window i={3}>
    <H3>გაკვეთილი  3:</H3>
    <H1>ტერმინალები(Terminals)</H1>
    <br/>
    <P>ამ კურსის გავლის დროს, თქვენ ლინუქსის ტერმინალთან ხშირად გექნებათ შეხება. ეს იმიტომ, რომ ყველაფრის გაკეთება შეიძლება მათი დახმარებით. თქვენ GUI-ს ქონაც კი არ გჭირდებათ. იმის თქმა გვინდა, რომ ტერმინალით ნებისმიერი რამის გაკეთებაა შესაძლებელი. რა არის ტერმინალი? ტერმინალი არის აპლიკაცია, რომელიც წვდომას ლინუქსის <InlineCode>ნიჟარაზე(Shell)</InlineCode> განიჭებთ წვდომას.</P>
    <P>ახლა შესაძლოა იკითხოთ: “რა არის ლინუქსის ნიჟარა?”. ამაზე პასუხის გასაცემად იმაზე უნდა ვისაუბროთ თუ როგორ მუშაობს ლინუქსი. ძირითადად, ლინუქსი არაა ოპერაციული სისტემა, ის <InlineCode>კერნელია(Kernel)</InlineCode>. კერნელი არის ოპერაციული სისტემის ბირთვი. ანუ, ლინუქსის დისტრიბუტივები ოპერაციული სისტემებია, მაგრამ თვითონ ლინუქსი კერნელია. ოპერაციულ სისტემაზე შეგვიძლია <InlineCode>UI-ს(User Interface)</InlineCode> დაშენება. ამის მისაღწევად ჩვენ კერნელთან კომუნიკაცია გვჭირდება. ეს ძალიან რთულია, რადგან კერნელის <InlineCode>ენა</InlineCode> კომპლექსურია. ამის გამო, ნიჟარა გამოიგონეს ის იმ ბრძანებებს ამარტივებს, რომლებიც კერნელს უნდა გავუგზავნოთ. ტერმინალები პროგრამებია, რომლებიც წვდომას ნიჟარებზე გვაძლევენ.</P>
    <P>ახლა ჩვენ ტერმინალების საბაზისო კონცეპტებს ავხსნით. როდესაც ტერმინალს გახსნით, თქვენ მასში ნებისმიერი რამის ჩაწერა შეგეძლებათ. მაგრამ ეს “ნებისმიერი რამ” უმჯობესია თუ ბრძანება იქნება, რომელსაც კომპიუტერი უნდა მიჰყვეს. სინამდვილეში, ეს ბრძანებებიც პროგრამებია. გახსენით ტერმინალი და დაწერეთ:</P>
    <CMD>ping -c 4 google.com</CMD>
    <P>ეს ბრძანება <InlineCode>ICMP ექო მოთხოვნას</InlineCode> (გირჩევთ ჩვენი ქსელის კურსის აღებას) გუგლის ვებსერვერს ოთხჯერ უგზავნის. რეალურად, <InlineCode>ping</InlineCode> არის ფაილის სახელი, რომელიც <InlineCode>/usr/bin/</InlineCode> დირექტორიაში(ჩვენ ამ თემას მოგვიანებით განვიხილავთ) მდებარეობს. ამ პროგრამების შექმნა პროგრამირების ენებით შეიძლება. ახლა შესაძლოა იკითხოთ: “როგორ წყვეტს ნიჟარა თუ რა იქნება ბრძანება?”. პასუხი ძალიან მარტივია. ლინუქსში არსებობენ დირექტორიები(ფოლდერები), რომლებიც იმ ფაილების შესანახად გამოიყენება, რომლებიც ბრძანებები უნდა იყონ. ყველაფერი რაც იქ ინახება, ბრძანებებად მოისაზრება.</P>
    <P>როგორ უნდა აირჩიოთ ტერმინალი? სინამდვილეში, ყველა ტერმინალს შეუძლია ნებისმიერი ამოცანის შესრულება, მაგრამ უკეთესია თუ <InlineCode>Alacritty</InlineCode>-ს ან <InlineCode>Terminator</InlineCode>-ს გამოიყენებთ. <InlineCode>Alacritty</InlineCode>-ის გავუწევთ რეკომენდაციას, რადგან ის <InlineCode>GPU(Graphics Processing Unit)</InlineCode> ოპტიმიზირებული ტერმინალია და ის სხვებთან შედარებით სწრაფია.</P>
</Window>

<Window i={4}>
    <H3>გაკვეთილი  4:</H3>
    <H1>ნიჟარების საწყისები</H1>
    <br/>
    <P>სანამ ნიჟარების საბაზისო კონცეპტებზე საუბარს დავიწყებთ, უნდა გადაწყვიტოთ თუ რომელი ნიჟარის გამოყენება გსურთ. დამწყებთათვის, მნიშვნელობა არ აქვს თუ რომელს გამოიყენებენ, მაგრამ ჩვენ გვინდა გაჩვენოთ სხვადასხვა ნიჟარები და მათი დადებითი და უარყოფითი მხარეები. როგორც უკვე ვთქვით, ყველაფერი პროგრამაა. ნიჟარებიც პროგრამები არიან. ბევრი ლინუქსის დისტრო იყენებს <InlineCode>bash</InlineCode> ნიჟარას ნაგულისხმევ(Default) ნიჟარად. მას ბრძანების ისტორიის შენახვა და ბრძანებების თავისით დასრულება(Autocomplete) შეუძლია, როდესაც <InlineCode>TAB</InlineCode> ღილაკს დააჭერთ თქვენს კლავიატურაზე. მისი შემოკლებული სახელის სრული ვერსია არის <InlineCode>Bourne-Again SHell</InlineCode>.</P>
    <P>მეორე ნიჟარა არის <InlineCode>zsh</InlineCode>. ეს შედარებით დახვეწილი ნიჟარაა და მეტი შესაძლებლობა აქვს, რომელიც შესაძლოა დამწყებებს გამოადგეთ. მაგალითად, მას ბრძანებათა ისტორიიდან დასრულებული ბრძანებების ჩვენება შეუძლია, როდესაც კონკრეტული ბრძანება ჯერ არ გაქვთ დასრულებული. ამ მაგალითს შეხედეთ:</P>
    <IMG src="/courses/Linux/1.webp" />
    <P>როგორც ხედავთ, ჩვენ მხოლოდ <InlineCode>ping</InlineCode> დავწერეთ, მაგრამ ის გვაჩვენებს მაგალითს ამ ბრძანებისთვის, რომლის გამოყენებაც შესაძლებელია. ამ შემთხვევაში, <InlineCode>Zsh</InlineCode> ამ მაგალითს ბრძანებათა ისტორიაში ეძებს. მას ასევე <InlineCode>spelling</InlineCode>(თუ სიტყვა არასწორად დაწერეთ, მაგალითად <InlineCode>ping</InlineCode> სიტყვის ნაცვლად <InlineCode>pign</InlineCode> გიწერიათ, <InlineCode>Zsh</InlineCode>-ს აქვს უნარი, რომ გაასწოროს ეს შეცდომა) შეცდომების გასწორება შეუძლია.</P>
    <P>შემდეგი ნიჟარა გახლავთ <InlineCode>fish</InlineCode>. ეს ძალიან ჰგავს <InlineCode>Zsh</InlineCode>-ს, მაგრამ მათ შორის განსხვავება მაინც არსებობს. მაგალითად, მას ჩაშენებული დახმარების სისტემა აქვს და მომხმარებლებს შეუძლიათ საკუთარი ფუნქციების და ბრძანებების დაწერა. თქვენ ნებისმიერი მათგანი შეგიძლიათ, რომ გამოიყენოთ, მაგრამ დამწყებებს <InlineCode>Bash</InlineCode>-ს ვურჩევთ. სხვა ნიჟარებიც არსებობს, მაგრამ ამჟამად ისინი მნიშვნელოვანნი არ არიან.</P>
    <P>სანამ საბაზისო ბრძანებებზე და სტრუქტურაზე ვისაუბრებთ, ჩვენ <InlineCode>პრომპტების(Prompt)</InlineCode> განხილვა გვსურს. პრომპტი არის ტექსტი, რომელიც ბრძანებამდე წერია. უმეტეს შემთხვევებში, ისინი ინფორმაციას შეიცავენ ლოკაციაზე, მომხმარებელზე და ჰოსტის სახელზე(Hostname). ეს <InlineCode>Bash</InlineCode> ნიჟარის საბაზისო პრომპტია:</P>
    <IMG src="/courses/Linux/2.webp" />
    <P>ჩვენ წითელი ხაზები დავამატეთ, რათა პრომპტის სტრუქტურა ბევრად მარტივად წარმოვაჩინოთ. თავიდან, მომხმარებლის სახელის შესახებ იგებთ ინფორმაციას, რომელიც არის <InlineCode>cup</InlineCode>. შემდეგ, მოცემულია კომპიუტერის <InlineCode>ჰოსტნეიმი(Hostname)</InlineCode>, რომელიც არის <InlineCode>SilverFish</InlineCode>. ბოლო ინფორმაცია არის ლოკაციის შესახებ, რომელიც არის <InlineCode>~</InlineCode>. ეს სიმბოლო ნიშნავს, რომ ჩვენ home დირექტორიაში(ლინუქსში, ფოლდერებს დირექტორიები ჰქვიათ) ვართ. როგორც ხედავთ, ნაჩვენებია <InlineCode>$</InlineCode> სიმბოლო. ეს ნიშნავს, რომ ჩვენ არ ვართ <InlineCode>root</InlineCode> მომხმარებელი. მომხმარებლებს მომდევნო გაკვეთილებში განვიხილავთ, მაგრამ ამჟამად დაიმახსოვრეთ, რომ <InlineCode>root</InlineCode> მომხმარებელი არის ადმინისტრატორი და მას ყველაფრის უფლება აქვს. თუ <InlineCode>root</InlineCode> მომხმარებელზე გადავალთ, <InlineCode>$</InlineCode> სიმბოლო შეიცვლება და გახდება <InlineCode>#</InlineCode>სიმბოლო:</P>
    <IMG src="/courses/Linux/3.webp" />
    <P>თქვენ შეგიძლიათ პრომპტების შეცვლა(Customize), იმაზე დაყრდნობით თუ რომელ ნიჟარას იყენებთ.</P>
    <P>ახლა განვიხილოთ ფაილები, რომლებსაც ნიჟარები იყენებენ. პირველი ფაილი, რომელიც უნდა განვიხილოთ გახლავთ <InlineCode>.bash_history</InlineCode> ან <InlineCode>.zsh_history</InlineCode> და ა.შ.(ფაილის სახელი დამოკიდებულია იმაზე თუ რომელ ნიჟარას იყენებთ). ამ ფაილში, ბრძანებათა ისტორია ინახება. ყველა ბრძანება, რომელიც ოდესმე დაგიწერიათ ამ ფაილში ინახება.</P>
    <P>მეორე ფაილი არის <InlineCode>.bashrc</InlineCode> ან <InlineCode>.zshrc</InlineCode> და ა.შ.(ეს ასევე დამოკიდებულია იმაზე თუ რომელ ნიჟარას იყენებთ და ამიერიდან მხოლოდ <InlineCode>Bash</InlineCode>-ს მოვიყვანთ მაგალითად იმისათვის, რომ უფრო გასაგები იყოს ყველაფერი). ეს ფაილი შეიცავს ნიჟარის კონფიგურაციას. თქვენ შეგიძლიათ <InlineCode>დაარედაქტიროთ(Edit)</InlineCode> პრომპტი, დაამატოთ თქვენზე მორგებული ფუნქციები და ცვლადები(შეამოწმეთ ჩვენი პროგრამირების კურსები, რათა გაიგოთ ეს თემები), დაამატოთ ისეთი რაღაცები, რისი გაშვებაც(Execute) დასაწყისში გსურთ და ასე შემდეგ.</P>
</Window>

<Window i={5}>
    <H3>გაკვეთილი  5:</H3>
    <H1>სამუშაო დირექტორიების შეცვლა და ფაილების ჩვენება</H1>
    <br/>
    <P>წარმოიდგინეთ, რომ პრომპტის მიხედვით, თქვენ ხართ <InlineCode>/home/user/Desktop/</InlineCode> დირექტორიაში. ეს ნიშნავს, რომ თქვენ შეგიძლიათ იმ ფაილებთან იმუშაოთ, რომლებიც ამ დირექტორიაშია მოთავსებული. თუ თქვენ ფაილები და დირექტორიები გაქვთ დესკტოპზე(Desktop), მათ შესახებ ინფორმაციის ნახვა ტერმინალიდან შეგიძლიათ. პირველ რიგში, უნდა თუ რომელი ფაილები და ფოლდერები ინახება დესკტოპზე. ამის შემოწმება ეკრანზე შეგიძლიათ, მაგრამ მოდით ვთქვათ, რომ GUI არ არის და მხოლოდ ნიჟარიდან შეგვიძლია მუშაობა. ბრძანება, რომელიც საშუალებას გაძლევთ, რომ შეამოწმოთ თუ რომელიც ფაილები და დირექტორიები ინახება სამუშაო დირექტორიაში არის:</P>
    <CMD>ls</CMD>
    <P>ეს არის შემოკლებული <InlineCode>list</InlineCode>. ამ მაგალითს დააკვირდით:</P>
    <IMG src="/courses/Linux/4.webp" />
    <P>თქვენ ხედავთ, რომ ზოგიერთი სახელი წითელია, ხოლო სხვები თეთრადაა წარმოჩენილი. ეს იმიტომ, რომ <InlineCode>Bash</InlineCode>-ს მის საკონფიგურაციო ფაილში აქვს ფუნქცია, რომელიც ისეთ სახელებს უცვლის ფერს, რომლებიც დირექტორიებს ეკუთვნიან. წითელი სახელები ფოლდერებს ეკუთვნის, ხოლო თეთრები ფაილებს. ეს ნიშნავს, რომ <InlineCode>dir1</InlineCode> და <InlineCode>FBI_secret_files</InlineCode> არიან დირექტორიები(Folders). მეორე მხრივ, <InlineCode>file1.txt</InlineCode> და <InlineCode>file2.txt</InlineCode> ფაილებია, რომლებშიც მონაცემების ჩაწერა შეგვიძლია(ამ შემთხვევაში სტანდარტული ტექსტის).</P>
    <P>ასევე შესაძლებელია, რომ დირექტორიები და ფაილები შევქმნათ ნიჟარიდან. მოდით ვთქვათ, რომ ჩვენ ორი დირექტორიის შექმნა გვსურს, <InlineCode>dir1</InlineCode> და <InlineCode>dir2</InlineCode>. ამის მისაღწევად, შეგვიძლია <InlineCode> mkdir</InlineCode> ბრძანების ორჯერ გამოყენება:</P>
    <CMD>mkdir dir1</CMD>
    <CMD>mkdir dir2</CMD>
    <P>ასევე შესაძლებელია, რომ ეს ყველაფერი ერთი ბრძანებით გავაკეთოთ:</P>
    <CMD>mkdir dir1 dir2</CMD>
    <P>ეს ბრძანება არის შემოკლებული <InlineCode>MaKe DIRectory</InlineCode></P>
    <P>ფაილების ნიჟარიდან შესაქმნელად, შეგვიძლია <InlineCode>touch</InlineCode> ბრძანების გამოყენება. მაგალითად, თუ ჩვენ გვსურს ფაილის, სახელად <InlineCode>aNewFile.txt</InlineCode> შექმნა, ჩვენ ამის მიღწევა შეგვიძლია ტერმინალში ამის ჩაწერით:</P>
    <CMD>touch aNewFile.txt</CMD>
    <P>შეგვიძლია <InlineCode>ls</InlineCode> ბრძანება გამოვიყენოთ იმის შესამოწმებლად, არსებობენ თუ არა ეს დირექტორიები და ფაილები დესკტოპზე.</P>
    <P>თუ სამუშაო დირექტორიის შეცვლა გვსურს, შეგვიძლია <InlineCode>cd</InlineCode> ბრძანება გამოვიყენოთ. ეს არის შემოკლებული <InlineCode>Change Directory</InlineCode>. წარმოიდგინეთ, რომ ჩვენ ვიმყოფებით <InlineCode>/home/user/Desktop/</InlineCode> დირექტორიაში. თუ გვსურს, რომ <InlineCode>/home/user/</InlineCode> ფოლდერში გადავიდეთ, ორი ბრძანების გამოყენება შეგვიძლია:</P>
    <CMD>cd ..</CMD>
    <P>მეორე ბრძანება გახლავთ:</P>
    <CMD>cd /home/user/</CMD>
    <P>ჩვენ რეკომენდაციას პირველ ბრძანებას ვუწევთ. პირველი ბრძანება მომხმარებელს ერთი დირექტორიით უკან აბრუნებს. მაგალითად, თუ ვიმყოფებით <InlineCode>/var/www/html/</InlineCode> დირექტორიაში და უკან წასვლა გვსურს, მაშინ გამოვიყენებთ <InlineCode>cd ..</InlineCode> ბრძანებას. ის <InlineCode>/var/www/</InlineCode> დირექტორიაში გადაგვიყვანს.</P>
    <P>თუ დირექტორიაში შესვლა გვსურს, შეგვიძლია სასურველი დირექტორიის სახელი ჩავწეროთ <InlineCode>..</InlineCode> სიმბოლოების ნაცვლად. თუ ჩვენ დესკტოპზე ვართ და მოცემულია <InlineCode>secData</InlineCode> დირექტორია, მასში შესვლა შეგვიძლია ასე:</P>
    <CMD>cd secData/</CMD>
    <P><InlineCode> / </InlineCode> არაა საჭირო.</P>
</Window>

<Window i={6}>
    <H3>გაკვეთილი  6:</H3>
    <H1>ფაილების სტრუქტურა ლინუქსში</H1>
    <P>ამ გაკვეთილში, ჩვენ ვისაუბრებთ ლინუქსის ფაილების სტრუქტურაზე. ეს ძალიან მნიშვნელოვანი საკითხია, რადგან ყველამ უნდა იცოდეს თუ როგორ მუშაობს ფაილები ლინუქსში და რას ემსახურება თითოეული დირექტორია.მთავარი დირექტორია არის <InlineCode>/</InlineCode>. ჩვენ მას <InlineCode>Root დირექტორიას</InlineCode> ვეძახით. ეს იმიტომ, რომ ის პირველი ფოლდერია(Folder) და ყველაფერი მის შემდეგ მოდის.თუ <InlineCode>/</InlineCode> დირექტორიაში იმყოფებით და <InlineCode>cd ..</InlineCode> ბრძანებას დაწერთ, თქვენ ისევ <InlineCode>/</InlineCode> დირექტორიაში აღმოჩნდებით იმიტომ, რომ არაფერი დგას მის წინ.</P>
    <P>მთავარი დირექტორია შეიცავს რამდენიმე დირექტორიას. ესენია: <InlineCode>bin</InlineCode>, <InlineCode>boot</InlineCode>, <InlineCode>dev</InlineCode>, <InlineCode>etc</InlineCode>, <InlineCode>home</InlineCode>, <InlineCode>lib</InlineCode>, <InlineCode>lib64</InlineCode>, <InlineCode>media</InlineCode>, <InlineCode>mnt</InlineCode>, <InlineCode>opt</InlineCode>, <InlineCode>proc</InlineCode>, <InlineCode>root</InlineCode>, <InlineCode>sbin</InlineCode>, <InlineCode>srv</InlineCode>, <InlineCode>sys</InlineCode>, <InlineCode>tmp</InlineCode>, <InlineCode>usr</InlineCode> და <InlineCode>var</InlineCode></P>
    <P>პირველი დირექტორია არის <InlineCode>bin</InlineCode>. ეს დირექტორია შეიცავს საჭირო <InlineCode>binary ფაილებს(ბრძანებებს)</InlineCode>, რომლებიც სისტემის აღსადგენად და შესანარჩუნებლად(Maintaining) არის საჭირო. ეს არ არის ერთადერთი დირექტორია, რომელიც <InlineCode>executable</InlineCode> ფაილებს შეიცავს.</P>
    <P>მეორე დირექტორია არის <InlineCode>boot</InlineCode>. ეს დირექტორია <InlineCode>bootloader</InlineCode>-ს და ლინუქს კერნელს შეიცავს. <InlineCode>ბუთლოუდერი(Bootloader)</InlineCode> არის პროგრამა, რომელიც <InlineCode>OS</InlineCode>-ს რთავს. როდესაც თქვენ კომპიუტერს რთავთ, ბუთლოუდერი ოპერაციულ სისტემას ტვირთავს თქვენთვის.</P>
    <P>მესამე დირექტორია არის <InlineCode>dev</InlineCode>. ეს დირექტორია შეიცავს მოწყობილობის(Device) ფაილებს, რომელიც აპარატურასთან(Hardware) კომუნიკაციისთვის არის საჭირო.მოგვიანებით ამ კურსში ნახავთ, რომ ლინუქსში ყველაფერი ფაილია.მაგალითად, თქვენი HDD(Hard Disk Drive)  შესაძლოა იყოს <InlineCode>/dev/sda</InlineCode> და USB ფლეშ დრაივი შესაძლოა იყოს <InlineCode>/dev/sdb</InlineCode>. უმეტეს შემთხვევაში, ტექსტური ტერმინალი არის <InlineCode>/dev/tty1</InlineCode></P>
    <P>მეოთხე დირექტორია არის <InlineCode>etc</InlineCode>. ეს დირექტორია შეიცავს საკონფიგურაციო ფაილებს და გარკვეულ სისტემურ პარამეტრებს. მაგალითად, თუ <InlineCode>Apache2 ვებ სერვერს</InlineCode>  დააყენებთ ლინუქსზე, მისი საკონფიგურაციო ფაილები <InlineCode>/etc/httpd/</InlineCode> დირექტორიაში იქნება. ასევე, თქვენ შეგიძლიათ <InlineCode>DNS(Domain Name System)</InlineCode> სერვერი შეცვალოთ <InlineCode>/etc/resolv.conf</InlineCode> ფაილიდან.</P>
    <P>მეხუთე დირექტორია არის <InlineCode>home</InlineCode>. ეს დირექტორია შეიცავს ფოლდერებს, რომლებიც მომხმარებლებისთვისაა შექმნილი. თითოეულ მომხმარებელს(root მომხმარებლის გარდა) საკუთარი დირექტორია აქვს <InlineCode>/home</InlineCode> ფოლდერში და ამ დირექტორიების სახელები მომხმარებლის სახელებს ემთხვევა.</P>
    <P>ამის შემდეგ, გვაქვს <InlineCode>lib</InlineCode> და <InlineCode>lib64</InlineCode>. ეს დირექტორიები შეიცავენ საჭირო ბიბლიოთეკებს. რეალურად, ბევრი პროგრამაა ამ ბიბლიოთეკებზე დამოკიდებული(თუ გსურთ რომ ისწავლოთ თუ რა არის ბიბლიოთეკა და როგორ მუშაობს ის, ნახეთ ჩვენი პროგრამირების კურსები. პროგრამირების ცოდნა დაგჭირდებათ, როდესაც IT-სთვის ლინუქსთან მუშაობას დაიწყებთ).</P>
    <P>შემდეგ გვაქვს <InlineCode>media</InlineCode> და <InlineCode>mnt</InlineCode> დირექტორიები. ესენი ისეთი მოწყობილობებისთვის გამოიყენება, როგორებიცაა<InlineCode>USB ფლეშ დრაივები</InlineCode>  და <InlineCode>CD დისკები</InlineCode>. ასე, რომ ეს დირექტორიები მოშორებადი(Removable) მედიისთვის გამოიყენება.</P>
    <P>ამის შემდეგ, მოდის <InlineCode>opt</InlineCode>. მომდევნო გაკვეთილებში, ჩვენ გასწავლით თუ რას წარმოადგენენ <InlineCode>პაკეტთა მენეჯერები(Package Managers)</InlineCode>  და როგორ მუშაობენ ისინი, მაგრამ ამჟამად დაიმახსოვრეთ, რომ ეს დირექტორია შეიცავს <InlineCode>პაკეტებს(Package)</InlineCode>, რომლებიც არ ეკუთვნიან პაკეტთა მენეჯერს.</P>
    <P>ამის შემდეგ, მოდის <InlineCode>proc</InlineCode> დირექტორია. აქ, ვირტუალური ფაილებია მოთავსებული სისტემის პროცესებისთვის. ეს დინამიური დირექტორიაა და ის <InlineCode>რეალურ დროში(Real-time)</InlineCode> აჩვენებს ინფორმაციას სისტემის შესახებ.</P>
    <P>ამის შემდეგ, გვაქვს <InlineCode>root</InlineCode> დირექტორია. ეს home დირექტორიაა <InlineCode>root</InlineCode> მომხმარებლისთვის. სხვა მომხმარებლებს არ აქვთ ამ ფოლდერზე წვდომა.</P>
    <P>შემდეგ გვაქვს <InlineCode>sbin</InlineCode> დირექტორია. ის ასევე შეიცავს “შესრულებად”(Executable) ფაილებს(ბრძანებებს), მაგრამ ისინი <InlineCode>root</InlineCode> მომხმარებლისთვის არიან გამოყოფილი. მაგალითად, თუ თქვენ გსურთ, რომ Ubuntu სერვერი დაარესტარტოთ(Restart), მხოლოდ <InlineCode>root</InlineCode> მომხმარებელს აქვს უფლება, რომ <InlineCode>reboot</InlineCode> ბრძანება გამოიყენოს ამისთვის.</P>
    <P>შემდეგ, გვაქვს <InlineCode>srv</InlineCode> დირექტორია. ეს დირექტორია შეიცავს მონაცემებს, რომლებიც სისტემამ უნდა გამოიყენოს მომსახურებისთვის. მაგალითად, თუ თქვენ დაჰოსტილი(Hosted) გაქვთ ვებსერვერი ან <InlineCode>FTP სერვერი</InlineCode> ლინუქსზე, ისინი ამ დირექტორიას გამოიყენებენ თავიანთი საქმის სწორად გასაკეთებლად. ასევე შესაძლებელია, რომ მათ საკონფიგურაციო ფაილებში დირექტორია შეცვალოთ.</P>
    <P>ამის შემდეგ, გვაქვს <InlineCode>sys</InlineCode> დირექტორია. ამ დირექტორიაში ვირტუალური ფაილებია მოთავსებული, რომლებიც ინფორმაციას კერნელის პარამეტრებზე და კონფიგურაციაზე შეიცავენ.</P>
    <P>შემდეგ, გვაქვს <InlineCode>tmp</InlineCode>. ეს დირექტორია დროებითი ფაილების და დირექტორიების შესანახად გამოიყენება, რომლებიც პროცესების მიერ არიან გამოყენებული. როდესაც კომპიუტერს გადატვირთავთ(Reboot), ყველაფერი წაიშლება ამ დირექტორიიდან. ასე, რომ ნუ მოათავსებთ თქვენთვის საჭირო რამეებს აქ.მაგალითად, თუ პროგრამა დაწერეთ, მის source კოდს ნუ მოათავსებთ ამ ფოლდერში.ის გადატვირთვის შემდეგ წაიშლება.</P>
    <P>ამის შემდეგ, მოდის <InlineCode>usr</InlineCode> დირექტორია. ეს დირექტორია შეიცავს სპეციფიკურ მონაცემებს, ბიბლიოთეკებს და დოკუმენტაციას. ის <InlineCode>binary ფაილებსაც</InlineCode> შეიცავს.</P>
    <P>საბოლოოდ, გვაქვს <InlineCode>var</InlineCode> დირექტორია. ეს დირექტორია შეიცავს ცვლად მონაცემებს, მაგალითად, <InlineCode>სისტემის ლოგებს(Logs)</InlineCode></P>
</Window>

<Window i={7}>
    <H3>გაკვეთილი  7:</H3>
    <H1>ფაილებში შეტანა და გამოტანა</H1>
    <br/>
    <P>ამ გაკვეთილში, ჩვენ ვისაუბრებთ იმაზე თუ როგორ მუშაობს <InlineCode>I/O(Input/Output) ფაილებში</InlineCode> , როდესაც ლინუქსს ვიყენებთ. ბევრი გზა არსებობს ამ ყველაფრის ლინუქსის ტერმინალში გასაკეთებლად. მაგალითად, შესაძლებელია <InlineCode>TUI(Terminal User Interface)</InlineCode> <InlineCode>ტექსტ ედიტორების(Text editor)</InlineCode>, როგორებიცაა <InlineCode>Vim</InlineCode>-ის, <InlineCode>NeoVim</InlineCode>-ის, <InlineCode>Helix</InlineCode>-ის და <InlineCode>Nano</InlineCode>-ს გამოყენება, მაგრამ <InlineCode>TUI ტექსტ ედიტორებს</InlineCode> მომდევნო გაკვეთილებში განვიხილავთ. ჩვენ შეგვიძლია <InlineCode>cat</InlineCode> ბრძანება გამოვიყენოთ, რათა მონაცემები ამოვიკითხოთ ფაილებიდან. მაგალითად, მოდით შევქმნათ C++ ფაილი და მასში ეს კოდი ჩავწეროთ:</P>
    <Code language="cpp" text=
    {`#include <iostream>

int main(){
    std::cout << “Hello Nautillus!\n” << “Learn the art of hacking!” << std::endl;

    return 0;
}`} />
    <P>ვთქვათ, რომ ამ ფაილის სახელია <InlineCode>main.cpp</InlineCode>. ჩვენ <InlineCode>cat</InlineCode> ბრძანების გამოყენება ასე შეგვიძლია:</P>
    <CMD>cat main.cpp</CMD>
    <P>მაგალითის ჩვენებაც შეგვიძლია:</P>
    <IMG src="/courses/Linux/5.webp" />
    <P>როგორც ხედავთ, მონაცემები ამოვიკითხეთ ფაილიდან.</P>
    <P>მოდით მონაცემები ჩავწეროთ ფაილში. ამის გასაკეთებლად, შედარებით რთული ოპერაციების ჩატარებაა საჭირო, მაგრამ ნუ აღელდებით, ჩვენ ყველაფერს აგიხსნით. ვთქვათ, ამ ტექსტის ჩაწერა გვსურს <InlineCode>file.txt</InlineCode> ფაილში: <InlineCode>Write this data into the file!</InlineCode>, ამის მისაღწევად, ეს ბრძანება უნდა დავწეროთ:</P>
    <CMD>echo “Write this data into the file!” {">"} file.txt</CMD>
    <P>შესაძლოა ეს ყველაფერი თქვენთვის დამაბნევლად ჩანდეს, მაგრამ რეალურად, არ არის კომპლექსური. პირველი სიტყვა არის <InlineCode>echo</InlineCode>. ეს ბრძანება ძალიან მარტივია, როდესაც მას ტექსტს გადავცემთ, ის მას უკან გვიბრუნებს. ამ მაგალითს შეხედეთ:</P>
    <IMG src="/courses/Linux/6.webp" />
    <P>როგორც ხედავთ, მან ის გაიმეორა რაც დავწერეთ.ამ ტექსტს ფაილში <InlineCode>{">"}</InlineCode> სიმბოლოს დამატებით ვწერთ. ძირითადად, ის დასაბრუნებელ მნიშვნელობებს(იმის გასაგებად თუ რას წარმოადგენენ დასაბრუნებელი მნიშვნელობები, გაიარეთ ჩვენი პროგრამირების კურსები) ფაილებში აგზავნის. მაგალითად, ჩვენ შეგვიძლია <InlineCode>ping</InlineCode> ბრძანება გამოვიყენოთ <InlineCode>ICMP</InlineCode> ექო მოთხოვნების როუტერთან გასაგზავნად და მისი დასაბრუნებელი ტექსტი(Output) ფაილებში გადავაგზავნოთ:</P>
    <IMG src="/courses/Linux/7.webp" />
    <P>როგორც ხედავთ, მისი დასაბრუნებელი ტექსტი <InlineCode>output.txt</InlineCode> ფაილში ჩავწერეთ.</P>
    <P>საბოლოოდ, <InlineCode>{">"}</InlineCode> სიმბოლოს შემდეგ, ფაილის სახელია საჭირო. მაგალითად, ჩვენ დავწერეთ <InlineCode>file.txt</InlineCode> წინა მაგალითში, რაც ნიშნავს, რომ სამიზნე ფაილი არის <InlineCode>file.txt</InlineCode></P>
</Window>

<Window i={8}>
    <H3>გაკვეთილი  8:</H3>
    <H1>და შემდეგ თქვენ შეხვდით Vim-ს</H1>
    <br/>
    <P>IT ინდუსტრიაში, არსებობს ხუმრობა: “შეუძლებელია Vim-დან გამოსვლა”. სანამ 	ახლა შესაძლოა იკითხოთ: “რატომ უნდა ვიცოდე Vim-ის გამოყენება?”. პასუხი მარტივია: ფაილებზე წვდომის მარტივად მოსაპოვებლად და სწრაფად დასარედაქტირებლად. 	ახლა შესაძლოა იკითხოთ: “რატომ უნდა ვიცოდე Vim-ის გამოყენება?”. პასუხი მარტივია: ფაილებზე წვდომის მარტივად მოსაპოვებლად და სწრაფად დასარედაქტირებლად. ახლა შესაძლოა იკითხოთ: “რატომ უნდა ვიცოდე Vim-ის გამოყენება?”. პასუხი მარტივია: ფაილებზე წვდომის მარტივად მოსაპოვებლად და სწრაფად დასარედაქტირებლად. <InlineCode>Vim</InlineCode>-ის გამოყენებაზე დავიწყებთ საუბარს, ნება მოგვეცით აგიხსნათ თუ რა არის <InlineCode>Vim</InlineCode>. <InlineCode>Vim</InlineCode> არის ტექსტ ედიტორი, რომელიც 1991 წელს შეიქმნა. პრობლემა ისაა, რომ <InlineCode>UNIX</InlineCode>-ის ნაირ სისტემებს(როგორიცაა ლინუქსი) არ ჰქონდათ <InlineCode>GUI</InlineCode> და თუ ხალხს ფაილის რედაქტირება(Edit) მოუნდებოდა, მათ უნდა ჰქონოდათ ისეთი ინტერფეისი, რომელიც საშუალებას მისცემდა, რომ ფაილები დაერედაქტირებინათ. ძირითადად, <InlineCode>Vim</InlineCode> <InlineCode>notepad</InlineCode>-ვითაა(ტექსტ ედიტორი Windows-ზე), მაგრამ ის ტერმინალშია. პრობლემა ისაა, რომ ტერმინალში მაუსები არ არის. ეს ნიშნავს, რომ ერთადერთი გზა ნავიგაციისთვის არის კლავიატურა. ასე, რომ როდესაც <InlineCode>Vim</InlineCode>-ს იყენებთ, არსებობს საკვანძო სიტყვები(Keywords), რომლებიც ისეთი ქმედებებისთვისაა შექმნილი, რომლებსაც GUI სჭირდებათ. მაგალითად, თუ თქვენ ფაილის შენახვა გსურთ, არ შეგიძლიათ <InlineCode> CTRL + S </InlineCode> ღილაკებზე დაჭერა, თქვენ ჯერ <InlineCode>:</InlineCode> ღილაკს უნდა დააჭიროთ და შემდეგ უნდა დაწეროთ <InlineCode>w</InlineCode>, ან თუ ფაილის შენახვა და <InlineCode>Vim</InlineCode>-დან გასვლა გსურთ, <InlineCode>wq</InlineCode>. თუ <InlineCode>Vim</InlineCode>-დან ისე გასვლა გსრუთ, რომ ცვლილებები არ შეინახოთ, უნდა დააჭიროთ <InlineCode>:</InlineCode> ღილაკს და შემდეგ უნდა დაწეროთ <InlineCode>qa!</InlineCode>. დიახ, ეს ყველაფერი რთულად ჟღერს და ბევრი ადამიანისთვის ეს ასეც არის, მაგრამ როდესაც ლინუქსის სერვერებთან მუშაობას დაიწყებთ ნახავთ, რომ ფაილებზე წვდომის მოპოვება და მათი რედაქტირება სწრაფად მოხერხდეს. საკმარისი დრო არაა იმისათვის, რომ მაუსი გამოიყენოთ. ყველაფრის სწრაფად გაკეთება დაგჭირდებათ და თქვენი ერთადერთი მეგობარი კლავიატურა იქნება(მტანჯველად ჟღერს, მაგრამ ასე არაა).</P>
    <P>მოდით ფაილი გავხსნათ <InlineCode>Vim</InlineCode>-ით. ამის გასაკეთებლად, პირველ რიგში, არიჩიეთ ფაილი დასარედაქტირებლად. ამ მაგალითისთვის, ჩვენ <InlineCode>main.cpp</InlineCode> ფაილს გამოვიყენებთ:</P>
    <CMD>vim main.cpp</CMD>
    <P>თქვენ წარმატებით გახსენით ფაილი <InlineCode>Vim</InlineCode>-ის დახმარებით. ახლა, არაფერს დააწვეთ. თქვენ <InlineCode>ვისუალურ რეჟიმში(Visual mode)</InlineCode> ხართ. დიახ, <InlineCode>Vim</InlineCode>-ს რამდენიმე რეჟიმი აქვს: <InlineCode>ნორმალური რეჟიმი</InlineCode>, <InlineCode>ჩამატების რეჟიმი</InlineCode>, <InlineCode>ვიზუალური რეჟიმი</InlineCode> და <InlineCode>ბრძანების რეჟიმი</InlineCode>. სხვა რეჟიმებიც არსებობს, მაგრამ ამჟამად ისინი არ არიან მნიშვნელოვანი. პირველი რეჟიმი <InlineCode>Vim</InlineCode>-ის ჩართვისთანავე აქტიურდება. თქვენ შეგიძლიათ ტექსტში ნავიგაცია, კოპირება, ჩასმა, წაშლა და ბრძანებების გაცემა(Execute commands). მეორე რეჟიმი აქტიურდება, როდესაც <InlineCode>I</InlineCode> ღილაკს დააწვებით კლავიატურაზე(Vim-ის ახალ ვერსიებში, როგორიცაა Neovim, ნებისმიერ ღილაკზე დაჭერით აქტიურდება ჩასმის რეჟიმი). ამ რეჟიმით ფაილში ტექსტის ჩაწერა შეგიძლიათ. შემდეგ, გვაქვს ვიზუალური რეჟიმი. ეს რეჟიმი ტექსტის დასაჭრელად(Cutting) და წასაშლელად გამოიყენება. ბოლო, მაგრამ არა უკანასკნელი არის ბრძანების რეჟიმი. ეს ძალიან საინტერესოა, რადგან <InlineCode>Vim</InlineCode> ამ რეჟიმიდან კონტროლდება. როდესაც <InlineCode>Vim</InlineCode> ნებისმიერ რეჟიმშია და თქვენ <InlineCode> : </InlineCode> ღილაკს დააწვებით კლავიატურაზე, ბრძანების რეჟიმი ჩაირთვება. თუ ბრძანებების ნახვა გსურთ, მაშინ <InlineCode> TAB </InlineCode> ღილაკს დააჭირეთ, როდესაც ბრძანების რეჟიმში იქნებით. ჩვენ უკვე გასწავლეთ საბაზისო ბრძანებები, როგორიცაა შენახვა და გასვლა.</P>
    <P>ახლა შესაძლოა იკითხოთ: “რატომ უნდა ვიცოდე Vim-ის გამოყენება?”. პასუხი მარტივია: ფაილებზე წვდომის მარტივად მოსაპოვებლად და სწრაფად დასარედაქტირებლად.</P>
</Window>

<Window i={9}>
    <H3>გაკვეთილი  9:</H3>
    <H1>მომხმარებლები და ჯგუფები</H1>
    <br/>
    <P>ლინუქსში ძალიან მნიშვნელოვანია მომხმარებლებისა და ჯგუფების სწორი მენეჯმენტი. თუ ისინი სწორად არ არიან გამართული, წარმოიქმნება მოწყვლადობები, რომლებსაც ჰაკერები გამოიყენებენ სისტემის ექსპლუატაციისთვის. უმეტეს შემთხვევაში, ჰაკერები წვდომას პირდაპირ <InlineCode>root</InlineCode> მომხმარებელზე არ იღებენ. თავდაპირველად, ისინი წვდომას სხვა მომხმარებელზე იღებენ და პრივილეგიის ესკალაციით ისინი <InlineCode>root</InlineCode> მომხმარებელზე წვდომის მოპოვებას ახერხებენ. ამ ყველაფრის თავიდან ასარიდებლად, მომხმარებლების და ჯგუფების სწორი მენეჯმენტი დაგჭირდებათ.</P>
    <P>მოდით ჩავრთოთ ლინუქსის სერვერი. თავდაპირველად, ჩვენ <InlineCode>root</InlineCode> მომხმარებელი ვიქნებით. ჩვენ <InlineCode></InlineCode>Apache2 ვებსერვერის ინსტალაცია გვსურს, მაგრამ არ გვსურს, რომ ის <InlineCode>root</InlineCode> მომხმარებელზე იყოს მიმაგრებული, რადგან თუ ჰაკერები <InlineCode>RCE(Remote Code Execution)</InlineCode> <InlineCode>ექსპლოიტებს(Exploits)</InlineCode> აღმოაჩენენ, მათ ბრძანებების გაშვება <InlineCode>root</InlineCode> მომხმარებლის სახელით შეეძლებათ. ასე, რომ მოდით შევქმნათ მომხმარებელი სახელად <InlineCode>user</InlineCode>:</P>
    <CMD>adduser user</CMD>
    <P>ეს მოხდება:</P>
    <IMG src="/courses/Linux/8.webp" />
    <P>შესაძლოა იფიქროთ, რომ პაროლები არ დაგვიწერია, მაგრამ ეს ასე არ არის. ნიჟარებს აქვთ უნარი, რომ მომხმარებლისგან პაროლი ტერმინალში ჩვენების გარეშე მიიღონ. რა თქმა უნდა, თუ ნიჟარას თქვენზე მოირგებთ(Customize), ამ პარამეტრის(Setting) შეცვლას შეძლებთ.</P>
    <P>ახლა, ჩვენ <InlineCode>user</InlineCode> მომხმარებელზე უნდა გადავიდეთ. ამის გასაკეთებლად, ჩვენ <InlineCode>su</InlineCode> ბრძანების ასე გამოყენება დაგვჭირდება:</P>
    <CMD>su user</CMD>
    <P>ჩვენ <InlineCode>user</InlineCode> მომხმარებლის პაროლის ჩაწერა არ მოგვიწია, რადგან როგორც უკვე ვთქვით, <InlineCode>root</InlineCode> მომხმარებელს ყველაფრის უფლება აქვს. ამ მაგალითს შეხედეთ:</P>
    <IMG src="/courses/Linux/9.webp" />
    <P>ახლა, ჩვენ <InlineCode>user</InlineCode> მომხმარებელი ვართ და ამის გამო პრომპტი შეიცვალა. ჩვენ ამ მომხმარებლით არაფრის გაკეთება შეგვიძლია, რადგან მას <InlineCode>sudo</InlineCode> ბრძანების გამოყენების უფლება არ გააჩნია. ეს ბრძანება გამოიყენება ბრძანებების <InlineCode>root</InlineCode>-ად გასაშვებად. მაგალითად, თუ მომხმარებელი <InlineCode>sudo rm -rf file.txt</InlineCode> ბრძანებას დაწერს, ფაილი <InlineCode>root</InlineCode> მომხმარებლის მიერ წაიშლება. მომხმარებლებს ამ ბრძანების გამოყენება მხოლოდ მაშინ შეუძლიათ, თუ ისინი სპეციალურ ჯგუფში სახელად <InlineCode>wheel</InlineCode> არიან დამატებული და ასევე, მომხმარებლებმა თავიანთი პაროლები უნდა შეიყვანონ თუ სურთ, რომ <InlineCode>sudo</InlineCode> ბრძანება გამოიყენონ. მოდით ისევ <InlineCode>root</InlineCode> მომხმარებელს დავუბრუნდეთ და <InlineCode>user</InlineCode> მომხმარებელი <InlineCode>wheel</InlineCode> ჯგუფში დავამატოთ:</P>
    <CMD>usermod -aG wheel user</CMD>
    <P>ახლა <InlineCode>user</InlineCode> მომხმარებელს <InlineCode>sudo</InlineCode> ბრძანების გამოყენება შეუძლია.</P>
    <P>შესაძლოა ჯგუფებმა დაგაბნიონ. ჯგუფი არის მომხმარებელთა კოლექცია და ის მათ რამეზე აძლევს წვდომას. მაგალითად, როგორ უკვე ვთქვით, <InlineCode>wheel</InlineCode> ჯგუფი მომხმარებლებს წვდომას აძლევს <InlineCode>sudo</InlineCode> ბრძანებაზე.</P>
    <P>ჩვენ წარმატებით შევქმენით ახალი მომხმარებელი და დავამატეთ <InlineCode>wheel</InlineCode> ჯგუფში. ახლა შეგვიძლია ვებსერვერი დავაყენოთ და ახალი მომხმარებლიდან გავუშვათ.</P>
</Window>

<Window i={10}>
    <H3>გაკვეთილი  10:</H3>
    <H1>ფაილთა უფლებები</H1>
    <br/>
    <P>ამ გაკვეთილში, ჩვენ ვისაუბრებთ ფაილთა უფლებებზე. ეს ძალიან მნიშვნელოვანი საკითხია და ამის გამოა, რომ ყველაფერი ამ საკითხზეა დაშენებული და გთხოვთ ყურადღება მიაქციოთ თითოეულ დეტალს, რომელსაც ამ გაკვეთილში ვახსენებთ.</P>
    <P>როგორც უკვე ვთქვით, ლინუქსში ყველაფერი ფაილია. <InlineCode>უფლებათა ტიპების(Types)</InlineCode> ცოდნა ბევრ რამეში დაგეხმარებათ. პირველ რიგში, უნდა გაიაზროთ თუ რას წარმოადგენენ უფლებათა ტიპები. ლინუქსში, სამი სახის უფლება არსებობს: <InlineCode>წაკითხვა(Read)</InlineCode>, <InlineCode>ჩაწერა(Write)</InlineCode> და <InlineCode>გაშვება(Execute)</InlineCode>. <InlineCode>წაკითხვის</InlineCode>  უფლება ნიშნავს, რომ მომხმარებელს შეუძლია მონაცემების ფაილიდან ამოკითხვა. ის ნიშნავს, რომ მომხმარებელს იმ ინფორმაციის მოპოვება შეუძლია, რომელიც ფაილში წერია. <InlineCode>ჩაწერის</InlineCode> უფლება ნიშნავს, რომ მომხმარებელს შეუძლია მონაცემების ფაილში ჩაწერა. ის ნიშნავს, რომ მომხმარებელს ფაილში ინფორმაციის დამატება შეუძლია. <InlineCode>გაშვების</InlineCode> უფლება ნიშნავს, რომ მომხმარებელს ამ ფაილის გაშვების უფლება აქვს. მაგალითად, თუ თქვენ ამ კოდს ჩაწერთ <InlineCode>main.cpp</InlineCode> ფაილში:</P>
    <Code language="cpp" text=
    {`#include <iostream>

int main(){
    std::cout << "Yes, yes, it works!" << std::endl;

    return 0;
}`} />
    <P>და შემდეგ თქვენ მას ასე გადააკომპილირებთ:</P>
    <CMD>g++ main.cpp -o main</CMD>
    <P>და მას ასე გაუშვებთ:</P>
    <CMD>./main</CMD>
    <P>მეორე მხრივ, თქვენ ამ ფაილს ვერ გაუშვებთ თუ უფლება არ გაქვთ. რა თქმა უნდა, ფაილი <InlineCode>executable</InlineCode> უნდა იყოს მისი გაშვება რომ შეძლოთ. ეს მოხდება თუ ფაილის გაშვებას ეცდებით, მაგრამ ამის უფლება არ გექნებათ:</P>
    <IMG src="/courses/Linux/10.webp" />
    <P>მოდით ჩავრთოთ სერვერი და ვნახოთ უფლებები <InlineCode>/</InlineCode> დირექტორიაში:</P>
    <IMG src="/courses/Linux/11.webp" />
    <P>მაგალითად <InlineCode>lrwxrwxrwx</InlineCode> ავიღოთ. შესაძლოა ეს თქვენთვის ძალიან დამაბნევლად გამოიყურებოდეს, მაგრამ სინამდვილეში, ეს უბრალოდ ინფორმაციას გვაძლევს თუ ვის აქვს <InlineCode>უფლება(Permission)</InlineCode> და ვის არა.</P>
    <P>პირველი სიმბოლო ინფორმაციას გვაძლევს იმის შესახებ თუ რა ტიპის ფაილთან ვმუშაობთ. ამ შემთხვევაში, ის არის <InlineCode>l</InlineCode>, რაც ნიშნავს, <InlineCode>სიმბოლურ ლინკს(Symbolic link)</InlineCode>. სიმბოლური ლინკების შესახებ მოგვიანებით ვისაუბრებთ ამ კურსში. ეს სიმბოლოები შეიძლება იყონ: <InlineCode>-</InlineCode>, <InlineCode>d</InlineCode>, <InlineCode>l</InlineCode>, <InlineCode>c</InlineCode> და <InlineCode>b</InlineCode>. პირველი სიმბოლო ნიშნავს, რომ მუშაობა გვიწევს რეგულარულ ფაილთან. მეორე სიმბოლო ნიშნავს, რომ საქმე დირექტორიასთან გვაქვს. ჩვენ უკვე ვისაუბრეთ მესამე სიმბოლოზე. მეოთხე სიმბოლო ნიშნავს, რომ ფაილი არის <InlineCode>character device</InlineCode> ფაილი.მ ეხუთე სიმბოლო კი ნიშნავს, რომ ფაილი არის <InlineCode>block device</InlineCode> ფაილი.</P>
    <P>დროა უფლებებზე ვისაუბროთ.სექცია <InlineCode>rwxrwxrwx</InlineCode> სამ ნაწილადაა დაყოფილი. თითოეული ნაწილი სამი სიმბოლოსგან შესდგება. ამ შემთხვევაში, მომხმარებელს შეუძლია წაკითხვა, ჩაწერა და ფაილის გაშვება. მეორე ნაწილი ინფორმაციას ჯგუფის უფლებებზე გვაძლევს. ამ შემთხვევაში, ჯგუფს აქვს წაკითხვის, ჩაწერის და ფაილის გაშვების უფლება. ბოლო ნაწილი ინფორმაციას სხვების უფლებებზე გვაძლევს. ამ შემთხვევაში, სხვებს შეუძლიათ წაიკითხონ, ჩაწერონ და გაუშვან ფაილი.</P>
    <P>მოდით სხვა მაგალითი განვიხილოთ. ამ შემთხვევაში, მოცემულია <InlineCode>-r-xr-x---</InlineCode>. პირველი სიმბოლო არის <InlineCode>-</InlineCode>, რაც ნიშნავს, რომ რეგულარულ ფაილთან გვაქვს შეხება. შემდეგ, თქვენ ხედავთ, რომ მომხმარებელს უფლება აქვს ფაილის წაკითხვის და გაშვების, მაგრამ არ აქვს უფლება, რომ ფაილში მონაცემები მოათავსოს. შემდეგ გვაქვს ჯგუფის უფლებები. ის იგივეა რაც მომხმარებლის უფლებები. საბოლოოდ, გვაქვს სხვების უფლებები. სხვებს არანაირი უფლება გააჩნიათ.</P>
    <P>უფლებების შემდეგ, გვაქვს ფაილის მფლობელი მომხმარებელი და ჯგუფი.მოდით ეს მაგალითი განვიხილოთ: <InlineCode>-rwxrwx--- Ricco sap </InlineCode>. ამ შემთხვევაში, ამ ფაილის მფლობელი მომხმარებელია <InlineCode>Ricco</InlineCode> და ჯგუფი, რომელიც ფლობს ფაილს არის <InlineCode>sap</InlineCode>. რეალურად, ჯგუფი არ ფლობს ფაილს, ის უბრალოდ ასოცირებულია ამ ფაილთან.</P>
    <P>რატომ არის მნიშვნელოვანი ფაილთა უფლებების ცოდნა? იმიტომ, რომ თუ ფაილთა უფლებების მენეჯმენტი კარგად არ იცით, ჰაკერები მარტივად აიღებენ წვდომას სენსიტიურ ინფორმაციაზე. ეს მაგალითი ნახეთ:</P>
    <IMG src="/courses/Linux/12.webp" />
    <P>როგორც ხედავთ, <InlineCode>root</InlineCode> მომხმარებელს ფაილის წაკითხვის უფლებაც კი არ გააჩნია, მაგრამ სხვებს ამ ფაილის წაკითხვის, ჩაწერის და გაშვების უფლება აქვთ. მომხმარებელი, რომელიც არ არის <InlineCode>root</InlineCode>, საიდუმლო ინფორმაციას მარტივად წაიკითხავს ამ ფაილიდან.</P>
</Window>

<Window i={11}>
    <H3>გაკვეთილი  11:</H3>
    <H1>ფაილის მფლობელის შეცვლა</H1>
    <br/>
    <P>ამ გაკვეთილში, ჩვენ ფაილის მფლობელის შეცვლაზე ვისაუბრებთ. ეს ძალიან გამოსადეგია, რადგან ფაილების და დირექტორიების მენეჯმენტი გვიმარტივდება.</P>
    <P>რატომ უნდა შეცვალოთ ფაილის მფლობელი? თუ მფლობელობის მენეჯმენტი სწორად გაქვთ აწყობილი, თქვენი სერვერი ბევრად დაცული იქნება. ჰაკერებს არასწორად დასმული მფლობელობის გამოყენება შეუძლიათ პრივილეგიის ესკალაციის შეტევებში.</P>
    <P>მოდით მაგალითი განვიხილოთ. წარმოიდგინეთ, რომ დოკუმენტების ფოლდერში გაქვთ ფაილი, სახელად <InlineCode>data.json</InlineCode> და თქვენ ამ ფაილის მფლობელის შეცვლა გსურთ. ფაილის მფლობელი გახლავთ <InlineCode>user</InlineCode> მომხმარებელი, მაგრამ თქვენ გსურთ, რომ მფლობელი <InlineCode>root</InlineCode> იყოს. იმისათვის, რომ <InlineCode>root</InlineCode> მომხმარებელი გახდეს ფაილის მფლობელი, თქვენ ამის დაწერა მოგიწევთ:</P>
    <CMD>chown root data.json</CMD>
    <P>ახლა, მოდით ყველა უფლება წავართვათ <InlineCode>user</InlineCode> მომხმარებელს ასე:</P>
    <CMD>chmod 700 data.json</CMD>
    <P>ამ ბრძანებაში, <InlineCode>700</InlineCode> ნიშნავს, რომ ჩვენ ფაილების უფლებები ასე დავსვით:</P>
    <CMD>
        -rwx------
    </CMD>
    <P>თქვენ უკვე იცით თუ რას გვეუბნება ეს. მხოლოდ იმ მომხმარებელს შეუძლია ფაილში ჩაწერა, წაკითხვა და ამ ფაილის გაშვება, რომელიც ფლობს ფაილს.</P>
    <P>ახლა, ფაილი სხვა მომხმარებლებისგან დაცულია. მხოლოდ <InlineCode>root</InlineCode> მომხმარებელს შეუძლია ფაილზე წვდომის მოპოვება. სხვა მომხმარებლებს ამ ფაილიდან ინფორმაციის ამოკითხვაც კი არ შეუძლიათ.</P>
</Window>

<Window i={12}>
    <H3>გაკვეთილი  12:</H3>
    <H1>როგორ მივიღოთ დახმარება</H1>
    <br/>
    <P>ლინუქსს ასი ათასობით ბრძანება აქვს. ჩვენ ყოველ მათგანს ვერ განვიხილავთ ამ კურსში. ფაქტობრივად, ამ ყველაფერს ვერავინ გააკეთებს. თქვენს კარიერაში ისეთი სიტუაციები იქნება, როდესაც რაღაცის გაკეთებას გადაწყვეტთ, მაგრამ ბრძანების გამოყენებას ვერ შეძლებთ.</P>
    <P>მაგალითად, თუ ფაილების <InlineCode>SSH-ით(Secure SHell)</InlineCode> გაგზავნა მოგინდებათ, <InlineCode>scp</InlineCode> ბრძანების გამოყენება მოგიწევთ. შესაძლებელია, რომ არ იცოდეთ ამ ბრძანების გამოყენება. დახმარების მიღება ორი წყაროდან შეგიძლიათ: თქვენ ამ ბრძანებას ონლაინ მოძებნით, ან <InlineCode>man</InlineCode> ბრძანებას გამოიყენებთ, ტერმინალში ბრძანების დოკუმენტაციის წასაკითხად. მაგალითად, თუ არ იცით თუ როგორ გააგზავნოთ ფაილები <InlineCode>SSH</InlineCode>-ით <InlineCode>scp</InlineCode> ბრძანების გამოყენებით, ეს ბრძანება დაწერეთ ტერმინალში:</P>
    <CMD>man scp</CMD>
    <P>ეს ბრძანება ტერმინალში დოკუმენტაციას დასვავს. შემდეგ კი <InlineCode>scp</InlineCode> ბრძანებაზე დოკუმენტაცია გექნებათ.</P>
    <P>გთხოვთ გაითვალისწინოთ, რომ ყველა ბრძანებას არ აქვს დოკუმენტაცია <InlineCode>man</InlineCode> ბრძანებაში. მაგალითად, თუ გსურთ ნახოთ <InlineCode>msfconsole</InlineCode> ბრძანების გამოყენების ინსტრუქცია, თქვენ <InlineCode>man</InlineCode> ბრძანებიდან ამას ვერ იზამთ, რადგან დოკუმენტაცია არ არის მასში .თქვენ <InlineCode>msfconsole</InlineCode> ბრძანებაზე ინფორმაციის მოძიება ონლაინ მოგიწევთ.</P>
    <P>დახმარების მიღების სხვა მეთოდი არსებობს. თითქმის ყველა ბრძანებას აქვს <InlineCode>-h</InlineCode> ან <InlineCode>--help</InlineCode> დროშა(დროშებს მოგვიანებით განვიხილავთ). ეს დროშები ნიშნავს, რომ თქვენ ბრძანების გამოყენების ინსტრუქციის ნახვა გსურთ. მაგალითად, თუ გსურთ <InlineCode>bash</InlineCode> ბრძანების გამოყენების წესების ნახვა, ეს უნდა დაწეროთ ტერმინალში:</P>
    <CMD>bash --help</CMD>
    <P>ეს დროშები უბრალო არგუმენტებია, რომლებიც ბრძანებიდან გადაეწოდება პროგრამას(ნახეთ ჩვენი პროგრამირების კურსები, რათა გაიგოთ თუ რას წარმოადგენენ არგუმენტები).</P>
    <P>თქვენ, როგორც ლინუქსის სერვერის ადმინისტრატორმა ან როგორც ჰაკერმა, უნდა შეძლოთ ბრძანების დოკუმენტაციის სწრაფად პოვნა. ყველა ინფორმაციის წყარო გამოიყენეთ, რათა დავალებები რაც შეიძლება სწრაფად შეასრულოთ. უბრალოდ წარმოიდგინეთ, რომ თქვენ ხართ ჰაკერი, რომელიც სამთავრობო ვებსაიტს ესხმის თავს. რაღაც ბრძანების გამოყენება გჭირდებათ, მაგრამ არ იცით თუ როგორ უნდა ქნათ ეს. თქვენ ბრძანების დროშებზე ინფორმაციას ონლაინ ეძებთ. ეს ათობით წუთს წაიღებს. ეს ძალიან დიდი დროა. უბრალოდ <InlineCode>man</InlineCode> ბრძანება ან <InlineCode>--help</InlineCode> დროშა გამოიყენეთ. ასევე ძალიან მნიშვნელოვანია დავალებების სწრაფად შესრულება, როდესაც საქმე ლინუქსის სერვერის მართვას/ადმინისტრირებას ეხება. წარმოიდგინეთ, რომ თქვენ <InlineCode>დოკერის(Docker)</InlineCode> კონტეინერის შექმნა გსურთ და არ იცით ეს როგორ უნდა გააკეთოთ. ამ ინფორმაციის ონლაინ მოძიების ნაცვლად, უბრალოდ <InlineCode>man</InlineCode> ბრძანება გამოიყენეთ. დროის დაზოგვა თქვენი კომპანიის სხვა დეპარტამენტებსაც დაეხმარება გამოწვევების სწრაფად დაძლევაში.</P>
</Window>




        </>
    );
  }
  
  export default Test;